generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ========================
// Enums
// ========================

enum ActorType {
  USER
  ORG
}

enum OrgRole {
  OWNER
  ADMIN
  MEMBER
  FOLLOWER
}

enum AttachmentType {
  PROJECT
  EVENT
  POST
}

// ========================
// Identity layer (Users + Orgs share Actor behavior)
// ========================

model Actor {
  id        String    @id @default(cuid())
  type      ActorType
  createdAt DateTime  @default(now())

  // 1:1 backrefs (enforced by app logic + migrations)
  user User?
  org  Org?

  // Ownership
  projects Project[]
  events   Event[]
  posts    Post[]

  // Social graph
  // Outgoing: I follow others
  following Follow[] @relation("Following")
  // Incoming: others follow me
  followers Follow[] @relation("Followers")

  @@map("actors")
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  Actor @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  following Actor @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followingId])
  @@map("follows")
}

// ========================
// Users + Orgs
// ========================

model User {
  id           String   @id @default(cuid())
  actorId      String   @unique

  email        String   @unique
  passwordHash String
  username     String   @unique

  firstName    String?
  middleName   String?
  lastName     String?
  displayName  String?  // Preferred display name (overrides firstName + lastName)

  headline     String?
  bio          String?
  interests    String[] @default([])
  location     String?

  // Privacy setting
  isPublic     Boolean  @default(true)

  // Avatar (simple + explicit)
  avatarImageId String?
  avatarImage   Image?  @relation("UserAvatar", fields: [avatarImageId], references: [id], onDelete: SetNull)

  createdAt    DateTime @default(now())
  updatedAt  DateTime @updatedAt

  actor Actor @relation(fields: [actorId], references: [id], onDelete: Cascade)

  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")

  images         Image[] // uploaded files (metadata)
  orgMemberships OrgMember[]

  @@map("users")
}

model Org {
  id        String   @id @default(cuid())
  actorId   String   @unique

  name      String
  slug      String   @unique

  headline  String?
  bio       String?
  interests String[] @default([])
  location  String?

  // Address fields
  addressLine1 String?
  addressLine2 String?
  city         String?
  state        String?
  zip          String?

  // Parent Topic (placeholder using simple string for now)
  parentTopic  String?

  // Privacy setting
  isPublic     Boolean  @default(true)

  // Avatar (simple + explicit)
  avatarImageId String?
  avatarImage   Image?  @relation("OrgAvatar", fields: [avatarImageId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  actor Actor @relation(fields: [actorId], references: [id], onDelete: Cascade)

  members    OrgMember[]
  roleLabels OrgRoleLabel[]

  @@map("orgs")
}

model OrgMember {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  role      OrgRole  @default(MEMBER)
  createdAt DateTime @default(now())

  org  Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([orgId, role])
  @@map("org_members")
}

model OrgRoleLabel {
  id        String   @id @default(cuid())
  orgId     String
  role      OrgRole
  label     String
  createdAt DateTime @default(now())

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, role])
  @@map("org_role_labels")
}

// ========================
// Content owned by Actor
// ========================

model Project {
  id           String   @id @default(cuid())
  ownerActorId String

  title        String
  description  String
  tags         String[] @default([])

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner Actor @relation(fields: [ownerActorId], references: [id], onDelete: Cascade)

  // Descendant posts
  posts Post[]

  @@index([ownerActorId])
  @@map("projects")
}

model Event {
  id           String   @id @default(cuid())
  ownerActorId String

  title        String
  description  String
  dateTime     DateTime
  location     String
  latitude     Float?
  longitude    Float?

  tags         String[] @default([])

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner Actor @relation(fields: [ownerActorId], references: [id], onDelete: Cascade)

  // Descendant posts
  posts Post[]

  @@index([ownerActorId, dateTime])
  @@map("events")
}

// Standalone posts (no projectId/eventId) and descendant posts (exactly one parent)
// Note: enforce "projectId and eventId not both set" via app logic + a DB CHECK constraint in migration.
model Post {
  id           String   @id @default(cuid())
  ownerActorId String

  // Parent pointers (optional)
  projectId    String?
  eventId      String?

  title        String?
  content      String

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner   Actor    @relation(fields: [ownerActorId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  event   Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([ownerActorId, createdAt])
  @@index([projectId, createdAt])
  @@index([eventId, createdAt])
  @@map("posts")
}

// ========================
// Messaging
// ========================

model Message {
  id          String    @id @default(cuid())
  content     String
  senderId    String
  receiverId  String
  createdAt   DateTime  @default(now())
  readAt      DateTime?

  sender      User      @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    User      @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("messages")
}

// ========================
// Images + Attachments
// ========================

model Image {
  id           String   @id @default(cuid())
  url          String
  path         String
  altText      String?
  uploadedById String
  createdAt    DateTime @default(now())

  uploadedBy   User     @relation(fields: [uploadedById], references: [id], onDelete: Cascade)

  // Used for Project/Event/Post galleries (and any other attachable targets you add later)
  attachments  ImageAttachment[]

  // Backrefs for avatars
  userAvatarFor User[] @relation("UserAvatar")
  orgAvatarFor  Org[]  @relation("OrgAvatar")

  @@index([uploadedById])
  @@map("images")
}

model ImageAttachment {
  id        String         @id @default(cuid())
  imageId   String
  type      AttachmentType
  targetId  String
  sortOrder Int            @default(0)
  createdAt DateTime       @default(now())

  image Image @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@index([type, targetId])
  @@index([imageId])
  @@map("image_attachments")
}
